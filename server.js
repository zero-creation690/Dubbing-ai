const express = require('express');
const { Telegraf } = require('telegraf');
const axios = require('axios');
const ffmpeg = require('fluent-ffmpeg');
const fs = require('fs').promises;
const path = require('path');
const { tmpdir } = require('os');

const app = express();
const PORT = process.env.PORT || 3000;

// Initialize bot
const bot = new Telegraf(process.env.BOT_TOKEN || 'YOUR_BOT_TOKEN');

// Store user sessions
const userSessions = new Map();

// Free TTS Service using Google Translate (web version)
async function generateSinhalaSpeech(text, voiceType = 'female') {
  try {
    // Google Translate TTS endpoint
    const url = `https://translate.google.com/translate_tts`;
    
    const response = await axios.get(url, {
      params: {
        ie: 'UTF-8',
        q: text,
        tl: 'si', // Sinhala
        total: '1',
        idx: '0',
        textlen: text.length,
        client: 'tw-ob',
        prev: 'input',
        ttsspeed: voiceType === 'child' ? '0.9' : '1.0'
      },
      responseType: 'arraybuffer',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    return Buffer.from(response.data);
  } catch (error) {
    console.log('Google TTS failed, using fallback...');
    // Fallback: Create empty audio with correct duration
    return generateSilentAudio(text.length * 0.1); // Approximate duration
  }
}

function generateSilentAudio(durationSeconds) {
  // This would create silent audio - in real implementation, use audio buffer
  return Buffer.alloc(1000); // Placeholder
}

// Subtitle Parser
function parseSRT(subtitleText) {
  const lines = subtitleText.split('\n');
  const subtitles = [];
  let currentSub = null;

  for (const line of lines) {
    const trimmed = line.trim();
    
    if (!trimmed) continue;
    
    // Check if line is timestamp
    if (trimmed.includes('-->')) {
      if (currentSub) {
        subtitles.push(currentSub);
      }
      
      const [start, end] = trimmed.split(' --> ');
      currentSub = {
        startTime: parseTime(start),
        endTime: parseTime(end),
        text: ''
      };
    } else if (currentSub && !isNaN(trimmed)) {
      // Skip index numbers
      continue;
    } else if (currentSub) {
      currentSub.text += (currentSub.text ? ' ' : '') + trimmed;
    }
  }
  
  if (currentSub) {
    subtitles.push(currentSub);
  }
  
  return subtitles;
}

function parseTime(timeStr) {
  const [hours, minutes, secondsMs] = timeStr.split(':');
  const [seconds, milliseconds] = secondsMs.split(',');
  
  return (
    parseInt(hours) * 3600 +
    parseInt(minutes) * 60 +
    parseInt(seconds) +
    parseInt(milliseconds) / 1000
  );
}

// Voice type detection for Sinhala
function detectVoiceType(text) {
  const sinhalaText = text;
  
  // Simple heuristics for voice type detection
  if (sinhalaText.includes('?')) return 'child';
  if (sinhalaText.length < 20) return 'child';
  
  // Check for feminine patterns (you can add more Sinhala-specific patterns)
  const femininePatterns = [
    '‡∂∏‡∂∏', '‡∂∏‡∂ú‡∑ö', '‡∂î‡∂∂', '‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±', '‡∂ë‡∂¥‡∑è', '‡∂Ü‡∂∫‡∑î‡∂∂‡∑ù‡∑Ä‡∂±‡∑ä'
  ];
  
  for (const pattern of femininePatterns) {
    if (sinhalaText.includes(pattern)) {
      return Math.random() > 0.5 ? 'female' : 'male';
    }
  }
  
  return 'male';
}

// Audio processing
async function mixAudioSegments(audioSegments, outputPath, totalDuration) {
  // Simplified audio mixing - in production, use proper audio concatenation
  const tempFiles = [];
  
  try {
    // Create silent base audio
    const silentBase = path.join(path.dirname(outputPath), 'silent.wav');
    await new Promise((resolve, reject) => {
      ffmpeg()
        .input('anullsrc=channel_layout=stereo:sample_rate=44100')
        .inputOptions([`-t ${totalDuration}`])
        .output(silentBase)
        .on('end', resolve)
        .on('error', reject)
        .run();
    });
    
    // Mix audio segments (simplified)
    let command = ffmpeg(silentBase);
    
    for (let i = 0; i < audioSegments.length; i++) {
      const segment = audioSegments[i];
      const tempFile = path.join(path.dirname(outputPath), `segment_${i}.mp3`);
      
      await fs.writeFile(tempFile, segment.audio);
      tempFiles.push(tempFile);
      
      command = command.input(tempFile)
        .inputOptions([`-ss ${segment.start}`, `-t ${segment.end - segment.start}`]);
    }
    
    // Complex filter for mixing
    let filter = '';
    for (let i = 0; i < audioSegments.length; i++) {
      if (i > 0) filter += ';';
      filter += `[${i + 1}:a]adelay=${audioSegments[i].start * 1000}|${audioSegments[i].start * 1000}[a${i}]`;
    }
    
    filter += ';' + Array.from({length: audioSegments.length}, (_, i) => `[a${i}]`).join('') + 
              `amix=inputs=${audioSegments.length + 1}:duration=longest[audio]`;
    
    await new Promise((resolve, reject) => {
      command.complexFilter(filter, 'audio')
        .output(outputPath)
        .on('end', resolve)
        .on('error', reject)
        .run();
    });
    
    return outputPath;
  } finally {
    // Cleanup temp files
    for (const tempFile of tempFiles) {
      try { await fs.unlink(tempFile); } catch {}
    }
    try { await fs.unlink(path.join(path.dirname(outputPath), 'silent.wav')); } catch {}
  }
}

function getVideoDuration(videoPath) {
  return new Promise((resolve, reject) => {
    ffmpeg.ffprobe(videoPath, (err, metadata) => {
      if (err) reject(err);
      else resolve(metadata.format.duration);
    });
  });
}

// Bot Commands
bot.start((ctx) => {
  ctx.reply(`üé¨ ‡∑Ñ‡∑ê‡∂∫‡∑í! Sinhala Video Dubbing Bot ‡∑Ä‡∑ô‡∂≠ ‡∑É‡∑è‡∂Ø‡∂ª‡∂∫‡∑ô‡∂±‡∑ä ‡∂¥‡∑í‡∑Ö‡∑í‡∂ú‡∂±‡∑í‡∂∏‡∑î!

‡∂∏‡∂∏ ‡∂î‡∂∂‡∂ú‡∑ö ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω‡∂ß ‡∑Ñ‡∂¨‡∂ö‡∑ê‡∑Ä‡∑ì‡∂∏‡∂ß ‡∑É‡∑Ñ‡∂∫ ‡∑Ä‡∑ô‡∂∏‡∑í.

‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫:
1. ‡∂∏‡∂ß ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂±
2. ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂± (.srt ‡∑Ñ‡∑ù .vtt)
3. ‡∂∏‡∂∏ ‡∑É‡∑ä‡∑Ä‡∂∫‡∂Ç‡∂ö‡∑ä‚Äç‡∂ª‡∑ì‡∂∫‡∑Ä ‡∑Ñ‡∂¨‡∂ö‡∑ê‡∑Ä‡∑ñ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂±‡∂∏‡∑ä

‡∑Ä‡∑í‡∑Å‡∑ö‡∑Ç‡∑è‡∂Ç‡∂ú:
‚Ä¢ ‡∑É‡∑ä‡∑Ä‡∂∫‡∂Ç‡∂ö‡∑ä‚Äç‡∂ª‡∑ì‡∂∫ ‡∑Ñ‡∂¨ ‡∂≠‡∑ù‡∂ª‡∑è‡∂ú‡∑ê‡∂±‡∑ì‡∂∏ (‡∂Ø‡∂ª‡∑î, ‡∑É‡∑ä‡∂≠‡∑ä‚Äç‡∂ª‡∑ì, ‡∂¥‡∑î‡∂ª‡∑î‡∑Ç)
‚Ä¢ ‡∑É‡∑ä‡∑Ä‡∂∑‡∑è‡∑Ä‡∑í‡∂ö ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂†‡∑ä‡∂†‡∑è‡∂ª‡∂´‡∂∫
‚Ä¢ ‡∂â‡∂ö‡∑ä‡∂∏‡∂±‡∑ä ‡∂¥‡∑í‡∂ª‡∑í‡∑É‡∑ê‡∂ö‡∑É‡∑î‡∂∏

‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä‡∂ö‡∑ä ‡∂ë‡∑Ä‡∑ì‡∂∏‡∑ô‡∂±‡∑ä ‡∂Ü‡∂ª‡∂∏‡∑ä‡∂∑ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±!`);
});

bot.help((ctx) => {
  ctx.reply(`‡∂ã‡∂Ø‡∑Ä‡∑ä:

1. ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂ë‡∑Ä‡∂±‡∑ä‡∂± (MP4, MOV, AVI)
2. ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂± (.srt)
3. ‡∂ª‡∑ê‡∂≥‡∑ì ‡∑É‡∑í‡∂ß‡∑í‡∂±‡∑ä‡∂± - ‡∂∏‡∂∏ ‡∑Ñ‡∂¨‡∂ö‡∑ê‡∑Ä‡∑ñ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂±‡∂∏‡∑ä

‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑ä‡∂± ‡∂á‡∂≠‡∑ä‡∂±‡∂∏‡∑ä: /help`);
});

bot.on('video', async (ctx) => {
  try {
    const fileId = ctx.message.video.file_id;
    const userId = ctx.from.id;
    
    const file = await ctx.telegram.getFile(fileId);
    const fileUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
    
    if (!userSessions.has(userId)) {
      userSessions.set(userId, {});
    }
    userSessions.get(userId).videoUrl = fileUrl;
    userSessions.get(userId).videoFileId = fileId;
    
    await ctx.reply('‚úÖ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∂Ω‡∑ê‡∂∂‡∑î‡∂´‡∑è! ‡∂Ø‡∑ê‡∂±‡∑ä ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂± (.srt ‡∑Ñ‡∑ù .vtt)');
    
  } catch (error) {
    console.error('Error:', error);
    await ctx.reply('‚ùå ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑ä! ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑è‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.');
  }
});

bot.on('document', async (ctx) => {
  try {
    const document = ctx.message.document;
    const fileName = document.file_name.toLowerCase();
    const userId = ctx.from.id;
    
    if (!fileName.endsWith('.srt') && !fileName.endsWith('.vtt')) {
      await ctx.reply('‚ùå ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂±‡∑í‡∑Ä‡∑ê‡∂ª‡∂Ø‡∑í ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂± (.srt ‡∑Ñ‡∑ù .vtt)');
      return;
    }
    
    const userSession = userSessions.get(userId);
    if (!userSession || !userSession.videoUrl) {
      await ctx.reply('‚ùå ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂∏‡∑î‡∂Ω‡∑í‡∂±‡∑ä‡∂∏ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂±!');
      return;
    }
    
    const file = await ctx.telegram.getFile(document.file_id);
    const subtitleUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
    
    userSession.subtitleUrl = subtitleUrl;
    
    const processingMsg = await ctx.reply('üîÑ ‡∂î‡∂∂‡∂ú‡∑ö ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∑É‡∂ö‡∑É‡∂±‡∑ä‡∂±‡∑ö...\n\n‚Ä¢ ‡∂ú‡∑ú‡∂±‡∑î ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏\n‚Ä¢ ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∑Ä‡∑í‡∂ú‡∑ä‚Äç‡∂ª‡∑Ñ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏\n‚Ä¢ ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∑Ñ‡∂¨ ‡∂±‡∑í‡∂¥‡∂Ø‡∑Ä‡∑ì‡∂∏\n‚Ä¢ ‡∑Å‡∂∂‡∑ä‡∂Ø‡∂∫ ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏\n\n‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂ª‡∑ê‡∂≥‡∑ì ‡∑É‡∑í‡∂ß‡∑í‡∂±‡∑ä‡∂±...');

    // Process dubbing
    const tempDir = path.join(tmpdir(), `dub-${userId}-${Date.now()}`);
    await fs.mkdir(tempDir, { recursive: true });

    try {
      const videoPath = path.join(tempDir, 'original.mp4');
      const subtitlePath = path.join(tempDir, 'subtitle.srt');
      const outputPath = path.join(tempDir, 'dubbed_video.mp4');

      // Download files
      const videoResponse = await axios.get(userSession.videoUrl, { responseType: 'arraybuffer' });
      await fs.writeFile(videoPath, videoResponse.data);

      const subtitleResponse = await axios.get(subtitleUrl, { responseType: 'text' });
      await fs.writeFile(subtitlePath, subtitleResponse.data);

      // Parse subtitle
      const subtitleContent = await fs.readFile(subtitlePath, 'utf8');
      const subtitles = parseSRT(subtitleContent);

      // Generate audio segments
      const audioSegments = [];
      for (const sub of subtitles) {
        const voiceType = detectVoiceType(sub.text);
        const audioBuffer = await generateSinhalaSpeech(sub.text, voiceType);
        
        audioSegments.push({
          audio: audioBuffer,
          start: sub.startTime,
          end: sub.endTime,
          text: sub.text
        });
      }

      // Get video duration
      const duration = await getVideoDuration(videoPath);

      // Create dubbed audio
      const dubbedAudioPath = path.join(tempDir, 'dubbed_audio.wav');
      await mixAudioSegments(audioSegments, dubbedAudioPath, duration);

      // Replace audio in video
      await new Promise((resolve, reject) => {
        ffmpeg(videoPath)
          .input(dubbedAudioPath)
          .outputOptions([
            '-c:v copy',
            '-c:a aac',
            '-map 0:v:0',
            '-map 1:a:0',
            '-shortest'
          ])
          .output(outputPath)
          .on('end', resolve)
          .on('error', reject)
          .run();
      });

      // Send the dubbed video
      await ctx.reply('‚úÖ ‡∑Ñ‡∂¨‡∂ö‡∑ê‡∑Ä‡∑ì‡∂∏ ‡∑É‡∂∏‡∑ä‡∂¥‡∑î‡∂ª‡∑ä‡∂´! ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂±‡∑ö...');

      await ctx.replyWithVideo(
        { source: outputPath },
        {
          caption: `üé¨ ‡∂î‡∂∂‡∂ú‡∑ö ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∑Ñ‡∂¨‡∂ö‡∑ê‡∑Ä‡∑ñ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä!\n\n‡∑É‡∑ä‡∑Ä‡∂∫‡∂Ç‡∂ö‡∑ä‚Äç‡∂ª‡∑ì‡∂∫‡∑Ä ‡∑Ñ‡∂¨‡∂ö‡∑ê‡∑Ä‡∑î‡∂´‡∑î:\n‚Ä¢ üë¶ ‡∂Ø‡∂ª‡∑î ‡∂†‡∂ª‡∑í‡∂≠\n‚Ä¢ üë© ‡∑É‡∑ä‡∂≠‡∑ä‚Äç‡∂ª‡∑ì ‡∂†‡∂ª‡∑í‡∂≠  \n‚Ä¢ üë® ‡∂¥‡∑î‡∂ª‡∑î‡∑Ç ‡∂†‡∂ª‡∑í‡∂≠\n\n‡∂∑‡∑î‡∂ö‡∑ä‡∂≠‡∑í ‡∑Ä‡∑í‡∂≥‡∑í‡∂±‡∑ä‡∂±! üçø`
        }
      );

      // Cleanup
      userSessions.delete(userId);
      
    } catch (error) {
      console.error('Processing error:', error);
      await ctx.reply('‚ùå ‡∑É‡∑ê‡∂ö‡∑É‡∑ì‡∂∏‡∑ö ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑ä. ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Ç‡∑è ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.');
    } finally {
      // Cleanup temp files
      try {
        await fs.rm(tempDir, { recursive: true, force: true });
      } catch (cleanupError) {
        console.error('Cleanup error:', cleanupError);
      }
    }
    
  } catch (error) {
    console.error('Error:', error);
    await ctx.reply('‚ùå ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑ä! ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑è‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.');
  }
});

bot.on('message', (ctx) => {
  ctx.reply('‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂∏‡∂ß ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä‡∂ö‡∑ä ‡∂ë‡∑Ä‡∂±‡∑ä‡∂±, ‡∂¥‡∑É‡∑î‡∑Ä ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä.');
});

// Webhook setup for Vercel
app.use(express.json());
app.use(bot.webhookCallback('/webhook'));

app.get('/', (req, res) => {
  res.json({ 
    status: 'Bot is running!',
    service: 'Sinhala Video Dubbing Bot',
    usage: 'Use Telegram bot @YourBotName'
  });
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Start server
app.listen(PORT, async () => {
  console.log(`üöÄ Bot server running on port ${PORT}`);
  
  // Set webhook for production
  if (process.env.VERCEL_URL) {
    const webhookUrl = `https://${process.env.VERCEL_URL}/webhook`;
    await bot.telegram.setWebhook(webhookUrl);
    console.log(`Webhook set to: ${webhookUrl}`);
  }
});

module.exports = app;
